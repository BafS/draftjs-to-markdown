{"version":3,"sources":["webpack:///draftjs-to-markdown.js","webpack:///webpack/bootstrap 529055f136030213107b","webpack:///./js/common.js","webpack:///./js/index.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","forEach","obj","callback","key","hasOwnProperty","isEmptyString","str","undefined","length","trim","isList","blockType","Object","defineProperty","value","getBlockTagSymbol","block","type","blockTypesMapping","isAtomicBlock","entityRanges","_common","text","getEntityMarkdown","entityMap","entityKey","entity","data","url","src","width","height","getEntitySections","blockLength","sections","lastOffset","r","offset","push","start","end","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","COLOR","Array","BGCOLOR","FONTSIZE","FONTFAMILY","SUBSCRIPT","SUPERSCRIPT","CODE","STRIKETHROUGH","UNDERLINE","ITALIC","BOLD","range","i","style","startsWith","substring","sameStyleAsPrevious","styles","index","sameStyled","getStylesAtOffset","getStyleSections","styleSections","section","getSectionText","chars","map","ch","join","addInlineStyleMarkup","content","getStyleTagSectionMarkdown","addStylePropertyMarkdown","styleSection","styleString","getEntitySectionMarkdown","entitySection","entitySectionMarkdown","styleSectionText","stylePropertySections","stylePropertySectionText","stylePropertySection","sectionText","trimLeadingZeros","replacedText","replace","trimTrailingZeros","getBlockContentMarkdown","blockMarkdown","entitySections","getBlockStyle","getBlockStyleProperty","blockData","blockStyle","getBlockMarkdown","blockContentMarkdown","getDepthPadding","depth","padding","draftToMarkdown","editorContent","markdown","blocks","default","unstyled","header-one","header-two","header-three","header-four","header-five","header-six","unordered-list-item","ordered-list-item","blockquote"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAH,WACAK,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,QAAA,EAGAP,EAAAC,QAvBA,GAAAI,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDOM,SAASH,EAAQC,EAASE,GAE/BH,EAAOC,QAAUE,EAAoB,IAKhC,SAASH,EAAQC,GAEtB,YEjDM,SAASW,GAAQC,EAAaC,GACnC,GAAID,EACF,IAAK,GAAME,KAAOF,QACTG,eAAeR,KAAKK,EAAKE,IAC9BD,EAASC,EAAKF,EAAIE,IASnB,QAASE,GAAcC,GAC5B,MAAYC,UAARD,GAA6B,OAARA,GAA+B,IAAfA,EAAIE,QAAsC,IAAtBF,EAAIG,OAAOD,OASnE,QAASE,GAAOC,GACrB,MACgB,wBAAdA,GACc,sBAAdA,EFyBHC,OAAOC,eAAexB,EAAS,cAC7ByB,OAAO,IAETzB,EEtDeW,UFuDfX,EE1CegB,gBF2CfhB,EEjCeqB,UFqEV,SAAStB,EAAQC,EAASE,GAE/B,YG5EM,SAASwB,GAAkBC,GAChC,MAAOA,GAAMC,MAAQC,EAAkBF,EAAMC,MAM/C,QAASE,GAAcH,GACrB,SAAIA,EAAMI,aAAaZ,OAAS,IAAK,EAAAa,EAAAhB,eAAcW,EAAMM,OAS3D,QAASC,GAAkBC,EAAmBC,EAAmBH,GAC/D,GAAMI,GAASF,EAAUC,EACzB,OAAoB,SAAhBC,EAAOT,MAAmC,YAAhBS,EAAOT,KACnC,IAAWK,EAAX,KAAoBI,EAAOC,KAAKC,IAAhC,IAEkB,UAAhBF,EAAOT,KACT,KAAYS,EAAOC,KAAKE,IAAxB,IAEkB,kBAAhBH,EAAOT,KACT,kBAAyBS,EAAOC,KAAKG,MAArC,aAAuDJ,EAAOC,KAAKI,OAAnE,UAAmFL,EAAOC,KAAKE,IAA/F,uCAEKP,EAOT,QAASU,GAAkBZ,EAAsBa,GAC/C,GAAMC,MACFC,EAAa,CAqBjB,OApBAf,GAAapB,QAAQ,SAACoC,GAChBA,EAAEC,OAASF,GACbD,EAASI,MACPC,MAAOJ,EACPK,IAAKJ,EAAEC,OAAS,IAGpBH,EAASI,MACPC,MAAOH,EAAEC,OACTG,IAAKJ,EAAEC,OAASD,EAAE5B,OAClBiB,UAAWW,EAAEjC,MAEfgC,EAAaC,EAAEC,OAASD,EAAE5B,SAExB2B,EAAaF,GACfC,EAASI,MACPC,MAAOJ,EACPK,IAAKP,IAGFC,EAMT,QAASO,GAAsBzB,GAAuB,GAC5CM,GAA4BN,EAA5BM,KAAMoB,EAAsB1B,EAAtB0B,kBACRC,GACJC,MAAO,GAAIC,OAAMvB,EAAKd,QACtBsC,QAAS,GAAID,OAAMvB,EAAKd,QACxBuC,SAAU,GAAIF,OAAMvB,EAAKd,QACzBwC,WAAY,GAAIH,OAAMvB,EAAKd,QAC3ByC,UAAW,GAAIJ,OAAMvB,EAAKd,QAC1B0C,YAAa,GAAIL,OAAMvB,EAAKd,QAC5B2C,KAAM,GAAIN,OAAMvB,EAAKd,QACrB4C,cAAe,GAAIP,OAAMvB,EAAKd,QAC9B6C,UAAW,GAAIR,OAAMvB,EAAKd,QAC1B8C,OAAQ,GAAIT,OAAMvB,EAAKd,QACvB+C,KAAM,GAAIV,OAAMvB,EAAKd,QACrBA,OAAQc,EAAKd,OAqBf,OAnBIkC,IAAqBA,EAAkBlC,OAAS,GAClDkC,EAAkB1C,QAAQ,SAACwD,GAGzB,IAAK,GAFCnB,GAASmB,EAAMnB,OACf7B,EAAS6B,EAASmB,EAAMhD,OACrBiD,EAAIpB,EAAQoB,EAAIjD,EAAQiD,GAAK,EAChCD,EAAME,MAAMC,WAAW,UACzBhB,EAAaC,MAAMa,GAAKD,EAAME,MAAME,UAAU,GACrCJ,EAAME,MAAMC,WAAW,YAChChB,EAAaG,QAAQW,GAAKD,EAAME,MAAME,UAAU,GACvCJ,EAAME,MAAMC,WAAW,aAChChB,EAAaI,SAASU,GAAKD,EAAME,MAAME,UAAU,GACxCJ,EAAME,MAAMC,WAAW,eAChChB,EAAaK,WAAWS,GAAKD,EAAME,MAAME,UAAU,IAC1CjB,EAAaa,EAAME,SAC5Bf,EAAaa,EAAME,OAAOD,IAAK,KAKhCd,EAOF,QAASkB,GACdlB,EACAmB,EACAC,GAEA,GAAIC,IAAa,CAQjB,OAPID,GAAQ,GAAKA,EAAQpB,EAAanC,OACpCsD,EAAO9D,QAAQ,SAAC0D,GACdM,EAAaA,GAAcrB,EAAae,GAAOK,KAAWpB,EAAae,GAAOK,EAAQ,KAGxFC,GAAa,EAERA,EAMF,QAASC,GAAkBtB,EAAsBN,GACtD,GAAMyB,KAkCN,OAjCInB,GAAaC,MAAMP,KACrByB,EAAOlB,MAAQD,EAAaC,MAAMP,IAEhCM,EAAaG,QAAQT,KACvByB,EAAOhB,QAAUH,EAAaG,QAAQT,IAEpCM,EAAaI,SAASV,KACxByB,EAAOf,SAAWJ,EAAaI,SAASV,IAEtCM,EAAaK,WAAWX,KAC1ByB,EAAOd,WAAaL,EAAaK,WAAWX,IAE1CM,EAAaM,UAAUZ,KACzByB,EAAOb,WAAY,GAEjBN,EAAaO,YAAYb,KAC3ByB,EAAOZ,aAAc,GAEnBP,EAAaQ,KAAKd,KACpByB,EAAOX,MAAO,GAEZR,EAAaS,cAAcf,KAC7ByB,EAAOV,eAAgB,GAErBT,EAAaU,UAAUhB,KACzByB,EAAOT,WAAY,GAEjBV,EAAaW,OAAOjB,KACtByB,EAAOR,QAAS,GAEdX,EAAaY,KAAKlB,KACpByB,EAAOP,MAAO,GAETO,EAOT,QAASI,GACPlD,EACA8C,EACAvB,EACAC,GAEA,GAAM2B,MACE7C,EAASN,EAATM,IACR,IAAIA,EAAKd,OAAS,EAGhB,IAAK,GAFCmC,GAAeF,EAAsBzB,GACvCoD,SACKX,EAAIlB,EAAOkB,EAAIjB,EAAKiB,GAAK,EAC5BA,IAAMlB,GAASsB,EAAoBlB,EAAcmB,EAAQL,IAE3DW,EAAQ9C,KAAKgB,KAAKhB,EAAKmC,IAEvBW,EAAQ5B,IAAMiB,EAAI,IAElBW,GACEN,OAAQG,EAAkBtB,EAAcc,GACxCnC,MAAOA,EAAKmC,IACZlB,MAAOkB,EACPjB,IAAKiB,EAAI,GAEXU,EAAc7B,KAAK8B,GAIzB,OAAOD,GAMT,QAASE,GAAe/C,GACtB,GAAIA,GAAQA,EAAKd,OAAS,EAAG,CAC3B,GAAM8D,GAAQhD,EAAKiD,IAAI,SAACC,GACtB,OAAQA,GACN,IAAK,KACH,MAAO,UACT,KAAK,IACH,MAAO,OACT,KAAK,IACH,MAAO,MACT,KAAK,IACH,MAAO,MACT,SACE,MAAOA,KAGb,OAAOF,GAAMG,KAAK,IAEpB,MAAO,GAMF,QAASC,GAAqBhB,EAAeiB,GAClD,MAAc,SAAVjB,EACF,KAAYiB,EAAZ,KACmB,WAAVjB,EACT,IAAWiB,EAAX,IACmB,cAAVjB,EACT,KAAYiB,EAAZ,KACmB,kBAAVjB,EACT,KAAYiB,EAAZ,KACmB,SAAVjB,EACT,IAAYiB,EAAZ,IACmB,gBAAVjB,EACT,QAAeiB,EAAf,SACmB,cAAVjB,EACT,QAAeiB,EAAf,SAEKA,EAOT,QAASC,GAA2Bd,EAAgBxC,GAClD,GAAIqD,GAAUrD,CAId,QAHA,EAAAD,EAAArB,SAAQ8D,EAAQ,SAACJ,EAAO5C,GACtB6D,EAAUD,EAAqBhB,EAAOiB,EAAS7D,KAE1C6D,EAMF,QAASE,GAAyBC,GAA8B,GAC7DhB,GAAiBgB,EAAjBhB,OAAQxC,EAASwD,EAATxD,KACVqD,EAAUN,EAAe/C,EAC/B,IAAIwC,IAAWA,EAAOlB,OAASkB,EAAOhB,SAAWgB,EAAOf,UAAYe,EAAOd,YAAa,CACtF,GAAI+B,GAAc,SAclB,OAbIjB,GAAOlB,QACTmC,aAAyBjB,EAAOlB,MAAhC,KAEEkB,EAAOhB,UACTiC,wBAAoCjB,EAAOhB,QAA3C,KAEEgB,EAAOf,WACTgC,iBAA6BjB,EAAOf,SAApC,OAEEe,EAAOd,aACT+B,mBAA+BjB,EAAOd,WAAtC,KAEF+B,GAAe,IACf,SAAgBA,EAAhB,IAA+BJ,EAA/B,UAEF,MAAOA,GAQT,QAASK,GAAyBhE,EAAeQ,EAAmByD,GAClE,GAAMC,MACAf,EAAgBD,EACpBlD,GACC,OAAQ,SAAU,YAAa,gBAAiB,OAAQ,cAAe,aACxEiE,EAAc1C,MACd0C,EAAczC,KAEZ2C,EAAmB,EACvBhB,GAAcnE,QAAQ,SAAC8E,GACrB,GAAMM,GAAwBlB,EAC5BlD,GACC,QAAS,UAAW,WAAY,cACjC8D,EAAavC,MACbuC,EAAatC,KAEX6C,EAA2B,EAC/BD,GAAsBpF,QAAQ,SAACsF,GAC7BD,GAA4BR,EAAyBS,KAEvDH,GAAoBP,EAA2BE,EAAahB,OAAQuB,KAEtEH,EAAsB5C,KAAK6C,EAC3B,IAAII,GAAcL,EAAsBT,KAAK,GAI7C,OAHgClE,UAA5B0E,EAAcxD,WAAuD,OAA5BwD,EAAcxD,YACzD8D,EAAchE,EAAkBC,EAAWyD,EAAcxD,UAAW8D,IAE/DA,EAMF,QAASC,GAAiBD,GAC/B,GAAIA,EAAa,CAEf,IAAK,GADDE,GAAeF,EACV9B,EAAI,EAAGA,EAAIgC,EAAajF,QACR,MAAnB+E,EAAY9B,GADuBA,GAAK,EAE1CgC,EAAeA,EAAaC,QAAQ,IAAK,SAK7C,OAAOD,GAET,MAAOF,GAMF,QAASI,GAAkBJ,GAChC,GAAIA,EAAa,CAEf,IAAK,GADDE,GAAeF,EACV9B,EAAIgC,EAAajF,OAAS,EAAGiD,GAAK,GACjB,MAApBgC,EAAahC,GAD2BA,GAAK,EAE/CgC,EAAkBA,EAAa7B,UAAU,EAAGH,GAA5C,SAAuDgC,EAAa7B,UAAUH,EAAI,EAKtF,OAAOgC,GAET,MAAOF,GAMF,QAASK,GAAwB5E,EAAeQ,GACrD,GAAIL,EAAcH,GAChB,MAAOO,GAAkBC,EAAWR,EAAMI,aAAa,GAAGjB,IAAK,GAEjE,IAAM0F,MACAC,EAAiB9D,EAAkBhB,EAAMI,aAAcJ,EAAMM,KAAKd,OAWxE,OAVAsF,GAAe9F,QAAQ,SAACoE,EAASL,GAC/B,GAAIwB,GAAcP,EAAyBhE,EAAOQ,EAAW4C,EAC/C,KAAVL,IACFwB,EAAcC,EAAiBD,IAE7BxB,IAAU+B,EAAetF,OAAS,IACpC+E,EAAcI,EAAkBJ,IAElCM,EAAcvD,KAAKiD,KAEdM,EAAcpB,KAAK,IAMrB,QAASsB,GAAcpE,GAC5B,GAAImC,GAAS,EAIb,QAHA,EAAAzC,EAAArB,SAAQ2B,EAAM,SAACxB,EAAKW,GAClBgD,GAAa3D,EAAb,IAAoBW,EAApB,MAEKgD,EAMT,QAASkC,GAAsBC,EAAmBtB,GAChD,GAAMuB,GAAaH,EAAcE,EACjC,OAAIC,GACF,gBAAuBA,EAAvB,KAAsCvB,EAAtC,UAEKA,EAMT,QAASwB,GAAiBnF,EAAeQ,GACvC,GAAMqE,KACNA,GAAcvD,KAAKvB,EAAkBC,GACrC,IAAIoF,GAAuBR,EAAwB5E,EAAOQ,EAM1D,OALIR,GAAMW,OACRyE,EAAuBJ,EAAsBhF,EAAMW,KAAMyE,IAE3DP,EAAcvD,KAAK8D,GACnBP,EAAcvD,KAAK,MACZuD,EAAcpB,KAAK,IAG5B,QAAS4B,GAAgBC,GAEvB,IAAK,GADDC,GAAU,GACL9C,EAAI,EAAGA,EAAY,EAAR6C,EAAW7C,GAAK,EAClC8C,GAAW,GAEb,OAAOA,GAMM,QAASC,GAAgBC,GACtC,GAAMC,KAaN,OAZID,KAAe,cACTE,GAAsBF,EAAtBE,OAAQnF,EAAciF,EAAdjF,SACZmF,IAAUA,EAAOnG,OAAS,GAC5BmG,EAAO3G,QAAQ,SAACgB,GACd,GAAI2D,GAAUwB,EAAiBnF,EAAOQ,IAClC,EAAAH,EAAAX,QAAOM,EAAMC,QACf0D,EAAU0B,EAAgBrF,EAAMsF,OAAS3B,GAE3C+B,EAASpE,KAAKqC,QAIb+B,EAASjC,KAAK,IHvWtB7D,OAAOC,eAAexB,EAAS,cAC7ByB,OAAO,IAETzB,EGjFe0B,oBHkFf1B,EGwBewE,sBHvBfxE,EG0Ce4E,oBHzCf5E,EG6IeqF,uBH5IfrF,EG8KewF,2BH7KfxF,EG0OemG,mBHzOfnG,EG2PesG,oBH1PftG,EG4QeuG,0BH3QfvG,EGiSe0G,gBHhSf1G,EAAQuH,QG6UeJ,CA5bxB,IAAAnF,GAAA9B,EAAA,GAKM2B,GACJ2F,SAAU,GACVC,aAAc,KACdC,aAAc,MACdC,eAAgB,OAChBC,cAAe,QACfC,cAAe,SACfC,aAAc,UACdC,sBAAuB,KACvBC,oBAAqB,MACrBC,WAAY","file":"draftjs-to-markdown.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.forEach = forEach;\n\texports.isEmptyString = isEmptyString;\n\texports.isList = isList;\n\t\n\t\n\t/**\n\t* Utility function to execute callback for eack key->value pair.\n\t*/\n\tfunction forEach(obj, callback) {\n\t  if (obj) {\n\t    for (var key in obj) {\n\t      // eslint-disable-line no-restricted-syntax\n\t      if ({}.hasOwnProperty.call(obj, key)) {\n\t        callback(key, obj[key]);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t* The function returns true if the string passed to it has no content.\n\t*/\n\tfunction isEmptyString(str) {\n\t  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t* Function to check if a block is of type list.\n\t*/\n\tfunction isList(blockType) {\n\t  return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getBlockTagSymbol = getBlockTagSymbol;\n\texports.sameStyleAsPrevious = sameStyleAsPrevious;\n\texports.getStylesAtOffset = getStylesAtOffset;\n\texports.addInlineStyleMarkup = addInlineStyleMarkup;\n\texports.addStylePropertyMarkdown = addStylePropertyMarkdown;\n\texports.trimLeadingZeros = trimLeadingZeros;\n\texports.trimTrailingZeros = trimTrailingZeros;\n\texports.getBlockContentMarkdown = getBlockContentMarkdown;\n\texports.getBlockStyle = getBlockStyle;\n\texports.default = draftToMarkdown;\n\t\n\tvar _common = __webpack_require__(1);\n\t\n\t/**\n\t* Mapping block-type to corresponding markdown symbol.\n\t*/\n\tvar blockTypesMapping = {\n\t  unstyled: '',\n\t  'header-one': '# ',\n\t  'header-two': '## ',\n\t  'header-three': '### ',\n\t  'header-four': '#### ',\n\t  'header-five': '##### ',\n\t  'header-six': '###### ',\n\t  'unordered-list-item': '- ',\n\t  'ordered-list-item': '1. ',\n\t  blockquote: '> '\n\t};\n\t\n\t/**\n\t* Function will return markdown symbol for a block.\n\t*/\n\t\n\t\n\tfunction getBlockTagSymbol(block) {\n\t  return block.type && blockTypesMapping[block.type];\n\t}\n\t\n\t/**\n\t* Function to check if the block is an atomic entity block.\n\t*/\n\tfunction isAtomicBlock(block) {\n\t  if (block.entityRanges.length > 0 && (0, _common.isEmptyString)(block.text)) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t* Function will return markdown for Entity.\n\t*/\n\tfunction getEntityMarkdown(entityMap, entityKey, text) {\n\t  var entity = entityMap[entityKey];\n\t  if (entity.type === 'LINK' || entity.type === 'MENTION') {\n\t    return '[' + text + '](' + entity.data.url + ')';\n\t  }\n\t  if (entity.type === 'IMAGE') {\n\t    return '!(' + entity.data.src + ')';\n\t  }\n\t  if (entity.type === 'EMBEDDED_LINK') {\n\t    return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\" allowFullScreen />';\n\t  }\n\t  return text;\n\t}\n\t\n\t/**\n\t* The function returns an array of entity sections in blocks.\n\t* These will be areas in block which have same entity or no entity applicable to them.\n\t*/\n\tfunction getEntitySections(entityRanges, blockLength) {\n\t  var sections = [];\n\t  var lastOffset = 0;\n\t  entityRanges.forEach(function (r) {\n\t    if (r.offset > lastOffset) {\n\t      sections.push({\n\t        start: lastOffset,\n\t        end: r.offset - 1\n\t      });\n\t    }\n\t    sections.push({\n\t      start: r.offset,\n\t      end: r.offset + r.length,\n\t      entityKey: r.key\n\t    });\n\t    lastOffset = r.offset + r.length;\n\t  });\n\t  if (lastOffset < blockLength) {\n\t    sections.push({\n\t      start: lastOffset,\n\t      end: blockLength\n\t    });\n\t  }\n\t  return sections;\n\t}\n\t\n\t/**\n\t* The function will return array of inline styles applicable to the block.\n\t*/\n\tfunction getStyleArrayForBlock(block) {\n\t  var text = block.text,\n\t      inlineStyleRanges = block.inlineStyleRanges;\n\t\n\t  var inlineStyles = {\n\t    COLOR: new Array(text.length),\n\t    BGCOLOR: new Array(text.length),\n\t    FONTSIZE: new Array(text.length),\n\t    FONTFAMILY: new Array(text.length),\n\t    SUBSCRIPT: new Array(text.length),\n\t    SUPERSCRIPT: new Array(text.length),\n\t    CODE: new Array(text.length),\n\t    STRIKETHROUGH: new Array(text.length),\n\t    UNDERLINE: new Array(text.length),\n\t    ITALIC: new Array(text.length),\n\t    BOLD: new Array(text.length),\n\t    length: text.length\n\t  };\n\t  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n\t    inlineStyleRanges.forEach(function (range) {\n\t      var offset = range.offset;\n\t      var length = offset + range.length;\n\t      for (var i = offset; i < length; i += 1) {\n\t        if (range.style.startsWith('color-')) {\n\t          inlineStyles.COLOR[i] = range.style.substring(6);\n\t        } else if (range.style.startsWith('bgcolor-')) {\n\t          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n\t        } else if (range.style.startsWith('fontsize-')) {\n\t          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n\t        } else if (range.style.startsWith('fontfamily-')) {\n\t          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n\t        } else if (inlineStyles[range.style]) {\n\t          inlineStyles[range.style][i] = true;\n\t        }\n\t      }\n\t    });\n\t  }\n\t  return inlineStyles;\n\t}\n\t\n\t/**\n\t* Function returns true for a set of styles if the value of these styles at an offset\n\t* are same as that on the previous offset.\n\t*/\n\tfunction sameStyleAsPrevious(inlineStyles, styles, index) {\n\t  var sameStyled = true;\n\t  if (index > 0 && index < inlineStyles.length) {\n\t    styles.forEach(function (style) {\n\t      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n\t    });\n\t  } else {\n\t    sameStyled = false;\n\t  }\n\t  return sameStyled;\n\t}\n\t\n\t/**\n\t* The function will return inline style applicable at some offset within a block.\n\t*/\n\tfunction getStylesAtOffset(inlineStyles, offset) {\n\t  var styles = {};\n\t  if (inlineStyles.COLOR[offset]) {\n\t    styles.COLOR = inlineStyles.COLOR[offset];\n\t  }\n\t  if (inlineStyles.BGCOLOR[offset]) {\n\t    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n\t  }\n\t  if (inlineStyles.FONTSIZE[offset]) {\n\t    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n\t  }\n\t  if (inlineStyles.FONTFAMILY[offset]) {\n\t    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n\t  }\n\t  if (inlineStyles.SUBSCRIPT[offset]) {\n\t    styles.SUBSCRIPT = true;\n\t  }\n\t  if (inlineStyles.SUPERSCRIPT[offset]) {\n\t    styles.SUPERSCRIPT = true;\n\t  }\n\t  if (inlineStyles.CODE[offset]) {\n\t    styles.CODE = true;\n\t  }\n\t  if (inlineStyles.STRIKETHROUGH[offset]) {\n\t    styles.STRIKETHROUGH = true;\n\t  }\n\t  if (inlineStyles.UNDERLINE[offset]) {\n\t    styles.UNDERLINE = true;\n\t  }\n\t  if (inlineStyles.ITALIC[offset]) {\n\t    styles.ITALIC = true;\n\t  }\n\t  if (inlineStyles.BOLD[offset]) {\n\t    styles.BOLD = true;\n\t  }\n\t  return styles;\n\t}\n\t\n\t/**\n\t* For a given section in a block the function will return a further list of sections,\n\t* with similar inline styles applicable to them.\n\t*/\n\tfunction getStyleSections(block, styles, start, end) {\n\t  var styleSections = [];\n\t  var text = block.text;\n\t\n\t  if (text.length > 0) {\n\t    var inlineStyles = getStyleArrayForBlock(block);\n\t    var section = void 0;\n\t    for (var i = start; i < end; i += 1) {\n\t      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n\t        // $FlowFixMe\n\t        section.text.push(text[i]);\n\t        // $FlowFixMe\n\t        section.end = i + 1;\n\t      } else {\n\t        section = {\n\t          styles: getStylesAtOffset(inlineStyles, i),\n\t          text: [text[i]],\n\t          start: i,\n\t          end: i + 1\n\t        };\n\t        styleSections.push(section);\n\t      }\n\t    }\n\t  }\n\t  return styleSections;\n\t}\n\t\n\t/**\n\t* The function returns text for given section of block after doing required character replacements.\n\t*/\n\tfunction getSectionText(text) {\n\t  if (text && text.length > 0) {\n\t    var chars = text.map(function (ch) {\n\t      switch (ch) {\n\t        case '\\n':\n\t          return '\\\\s\\\\s\\n';\n\t        case '&':\n\t          return '&amp;';\n\t        case '<':\n\t          return '&lt;';\n\t        case '>':\n\t          return '&gt;';\n\t        default:\n\t          return ch;\n\t      }\n\t    });\n\t    return chars.join('');\n\t  }\n\t  return '';\n\t}\n\t\n\t/**\n\t* Function returns markdown for inline style symbols.\n\t*/\n\tfunction addInlineStyleMarkup(style, content) {\n\t  if (style === 'BOLD') {\n\t    return '**' + content + '**';\n\t  } else if (style === 'ITALIC') {\n\t    return '*' + content + '*';\n\t  } else if (style === 'UNDERLINE') {\n\t    return '__' + content + '__';\n\t  } else if (style === 'STRIKETHROUGH') {\n\t    return '~~' + content + '~~';\n\t  } else if (style === 'CODE') {\n\t    return '`' + content + '`';\n\t  } else if (style === 'SUPERSCRIPT') {\n\t    return '<sup>' + content + '</sup>';\n\t  } else if (style === 'SUBSCRIPT') {\n\t    return '<sub>' + content + '</sub>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* The method returns markup for section to which inline styles\n\t* BOLD, UNDERLINE, ITALIC, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n\t*/\n\tfunction getStyleTagSectionMarkdown(styles, text) {\n\t  var content = text;\n\t  (0, _common.forEach)(styles, function (style, value) {\n\t    content = addInlineStyleMarkup(style, content, value);\n\t  });\n\t  return content;\n\t}\n\t\n\t/**\n\t* Function returns html for text applying inline style in styles property in a span.\n\t*/\n\tfunction addStylePropertyMarkdown(styleSection) {\n\t  var styles = styleSection.styles,\n\t      text = styleSection.text;\n\t\n\t  var content = getSectionText(text);\n\t  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n\t    var styleString = 'style=\"';\n\t    if (styles.COLOR) {\n\t      styleString += 'color: ' + styles.COLOR + ';';\n\t    }\n\t    if (styles.BGCOLOR) {\n\t      styleString += 'background-color: ' + styles.BGCOLOR + ';';\n\t    }\n\t    if (styles.FONTSIZE) {\n\t      styleString += 'font-size: ' + styles.FONTSIZE + 'px;';\n\t    }\n\t    if (styles.FONTFAMILY) {\n\t      styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n\t    }\n\t    styleString += '\"';\n\t    return '<span ' + styleString + '>' + content + '</span>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* The method returns markdown for an entity section.\n\t* An entity section is a continuous section in a block\n\t* to which same entity or no entity is applicable.\n\t*/\n\tfunction getEntitySectionMarkdown(block, entityMap, entitySection) {\n\t  var entitySectionMarkdown = [];\n\t  var styleSections = getStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], entitySection.start, entitySection.end);\n\t  var styleSectionText = '';\n\t  styleSections.forEach(function (styleSection) {\n\t    var stylePropertySections = getStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], styleSection.start, styleSection.end);\n\t    var stylePropertySectionText = '';\n\t    stylePropertySections.forEach(function (stylePropertySection) {\n\t      stylePropertySectionText += addStylePropertyMarkdown(stylePropertySection);\n\t    });\n\t    styleSectionText += getStyleTagSectionMarkdown(styleSection.styles, stylePropertySectionText);\n\t  });\n\t  entitySectionMarkdown.push(styleSectionText);\n\t  var sectionText = entitySectionMarkdown.join('');\n\t  if (entitySection.entityKey !== undefined && entitySection.entityKey !== null) {\n\t    sectionText = getEntityMarkdown(entityMap, entitySection.entityKey, sectionText);\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Replace leading blank spaces by &nbsp;\n\t*/\n\tfunction trimLeadingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = 0; i < replacedText.length; i += 1) {\n\t      if (sectionText[i] === ' ') {\n\t        replacedText = replacedText.replace(' ', '&nbsp;');\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Replace trailing blank spaces by &nbsp;\n\t*/\n\tfunction trimTrailingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n\t      if (replacedText[i] === ' ') {\n\t        replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Function will return the markdown for block content.\n\t*/\n\tfunction getBlockContentMarkdown(block, entityMap) {\n\t  if (isAtomicBlock(block)) {\n\t    return getEntityMarkdown(entityMap, block.entityRanges[0].key, '');\n\t  }\n\t  var blockMarkdown = [];\n\t  var entitySections = getEntitySections(block.entityRanges, block.text.length);\n\t  entitySections.forEach(function (section, index) {\n\t    var sectionText = getEntitySectionMarkdown(block, entityMap, section);\n\t    if (index === 0) {\n\t      sectionText = trimLeadingZeros(sectionText);\n\t    }\n\t    if (index === entitySections.length - 1) {\n\t      sectionText = trimTrailingZeros(sectionText);\n\t    }\n\t    blockMarkdown.push(sectionText);\n\t  });\n\t  return blockMarkdown.join('');\n\t}\n\t\n\t/**\n\t* Function will return style string for a block.\n\t*/\n\tfunction getBlockStyle(data) {\n\t  var styles = '';\n\t  (0, _common.forEach)(data, function (key, value) {\n\t    styles += key + ':' + value + ';';\n\t  });\n\t  return styles;\n\t}\n\t\n\t/**\n\t* FUnciton will add <span> with style property aroung block content for block level text-styling.\n\t*/\n\tfunction getBlockStyleProperty(blockData, content) {\n\t  var blockStyle = getBlockStyle(blockData);\n\t  if (blockStyle) {\n\t    return '<span style=\"' + blockStyle + '\">' + content + '</span>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* Function will return markdown for the block.\n\t*/\n\tfunction getBlockMarkdown(block, entityMap) {\n\t  var blockMarkdown = [];\n\t  blockMarkdown.push(getBlockTagSymbol(block));\n\t  var blockContentMarkdown = getBlockContentMarkdown(block, entityMap);\n\t  if (block.data) {\n\t    blockContentMarkdown = getBlockStyleProperty(block.data, blockContentMarkdown);\n\t  }\n\t  blockMarkdown.push(blockContentMarkdown);\n\t  blockMarkdown.push('\\n');\n\t  return blockMarkdown.join('');\n\t}\n\t\n\tfunction getDepthPadding(depth) {\n\t  var padding = '';\n\t  for (var i = 0; i < depth * 4; i += 1) {\n\t    padding += ' ';\n\t  }\n\t  return padding;\n\t}\n\t\n\t/**\n\t* The function will generate markdown for given draftjs editorContent.\n\t*/\n\tfunction draftToMarkdown(editorContent) {\n\t  var markdown = [];\n\t  if (editorContent) {\n\t    (function () {\n\t      var blocks = editorContent.blocks,\n\t          entityMap = editorContent.entityMap;\n\t\n\t      if (blocks && blocks.length > 0) {\n\t        blocks.forEach(function (block) {\n\t          var content = getBlockMarkdown(block, entityMap);\n\t          if ((0, _common.isList)(block.type)) {\n\t            content = getDepthPadding(block.depth) + content;\n\t          }\n\t          markdown.push(content);\n\t        });\n\t      }\n\t    })();\n\t  }\n\t  return markdown.join('');\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// draftjs-to-markdown.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 529055f136030213107b","/* @flow */\n\n/**\n* Utility function to execute callback for eack key->value pair.\n*/\nexport function forEach(obj: Object, callback: Function) {\n  if (obj) {\n    for (const key in obj) { // eslint-disable-line no-restricted-syntax\n      if ({}.hasOwnProperty.call(obj, key)) {\n        callback(key, obj[key]);\n      }\n    }\n  }\n}\n\n/**\n* The function returns true if the string passed to it has no content.\n*/\nexport function isEmptyString(str: string): boolean {\n  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* Function to check if a block is of type list.\n*/\nexport function isList(blockType: string): any {\n  return (\n    blockType === 'unordered-list-item' ||\n    blockType === 'ordered-list-item'\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/common.js","/* @flow */\n\nimport { isEmptyString, forEach, isList } from './common';\n\n/**\n* Mapping block-type to corresponding markdown symbol.\n*/\nconst blockTypesMapping: Object = {\n  unstyled: '',\n  'header-one': '# ',\n  'header-two': '## ',\n  'header-three': '### ',\n  'header-four': '#### ',\n  'header-five': '##### ',\n  'header-six': '###### ',\n  'unordered-list-item': '- ',\n  'ordered-list-item': '1. ',\n  blockquote: '> ',\n};\n\n/**\n* Function will return markdown symbol for a block.\n*/\nexport function getBlockTagSymbol(block: Object): string {\n  return block.type && blockTypesMapping[block.type];\n}\n\n/**\n* Function to check if the block is an atomic entity block.\n*/\nfunction isAtomicBlock(block: Object): boolean {\n  if (block.entityRanges.length > 0 && isEmptyString(block.text)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* Function will return markdown for Entity.\n*/\nfunction getEntityMarkdown(entityMap: Object, entityKey: number, text: string): string {\n  const entity = entityMap[entityKey];\n  if (entity.type === 'LINK' || entity.type === 'MENTION') {\n    return `[${text}](${entity.data.url})`;\n  }\n  if (entity.type === 'IMAGE') {\n    return `!(${entity.data.src})`;\n  }\n  if (entity.type === 'EMBEDDED_LINK') {\n    return `<iframe width=\"${entity.data.width}\" height=\"${entity.data.height}\" src=\"${entity.data.src}\" frameBorder=\"0\" allowFullScreen />`;\n  }\n  return text;\n}\n\n/**\n* The function returns an array of entity sections in blocks.\n* These will be areas in block which have same entity or no entity applicable to them.\n*/\nfunction getEntitySections(entityRanges: Object, blockLength: number): Array<Object> {\n  const sections = [];\n  let lastOffset = 0;\n  entityRanges.forEach((r) => {\n    if (r.offset > lastOffset) {\n      sections.push({\n        start: lastOffset,\n        end: r.offset - 1,\n      });\n    }\n    sections.push({\n      start: r.offset,\n      end: r.offset + r.length,\n      entityKey: r.key,\n    });\n    lastOffset = r.offset + r.length;\n  });\n  if (lastOffset < blockLength) {\n    sections.push({\n      start: lastOffset,\n      end: blockLength,\n    });\n  }\n  return sections;\n}\n\n/**\n* The function will return array of inline styles applicable to the block.\n*/\nfunction getStyleArrayForBlock(block: Object): Object {\n  const { text, inlineStyleRanges } = block;\n  const inlineStyles = {\n    COLOR: new Array(text.length),\n    BGCOLOR: new Array(text.length),\n    FONTSIZE: new Array(text.length),\n    FONTFAMILY: new Array(text.length),\n    SUBSCRIPT: new Array(text.length),\n    SUPERSCRIPT: new Array(text.length),\n    CODE: new Array(text.length),\n    STRIKETHROUGH: new Array(text.length),\n    UNDERLINE: new Array(text.length),\n    ITALIC: new Array(text.length),\n    BOLD: new Array(text.length),\n    length: text.length,\n  };\n  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n    inlineStyleRanges.forEach((range) => {\n      const offset = range.offset;\n      const length = offset + range.length;\n      for (let i = offset; i < length; i += 1) {\n        if (range.style.startsWith('color-')) {\n          inlineStyles.COLOR[i] = range.style.substring(6);\n        } else if (range.style.startsWith('bgcolor-')) {\n          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n        } else if (range.style.startsWith('fontsize-')) {\n          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n        } else if (range.style.startsWith('fontfamily-')) {\n          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n        } else if (inlineStyles[range.style]) {\n          inlineStyles[range.style][i] = true;\n        }\n      }\n    });\n  }\n  return inlineStyles;\n}\n\n/**\n* Function returns true for a set of styles if the value of these styles at an offset\n* are same as that on the previous offset.\n*/\nexport function sameStyleAsPrevious(\n  inlineStyles: Object,\n  styles: Array<string>,\n  index: number,\n): boolean {\n  let sameStyled = true;\n  if (index > 0 && index < inlineStyles.length) {\n    styles.forEach((style) => {\n      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n    });\n  } else {\n    sameStyled = false;\n  }\n  return sameStyled;\n}\n\n/**\n* The function will return inline style applicable at some offset within a block.\n*/\nexport function getStylesAtOffset(inlineStyles: Object, offset: number): Object {\n  const styles = {};\n  if (inlineStyles.COLOR[offset]) {\n    styles.COLOR = inlineStyles.COLOR[offset];\n  }\n  if (inlineStyles.BGCOLOR[offset]) {\n    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n  }\n  if (inlineStyles.FONTSIZE[offset]) {\n    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n  }\n  if (inlineStyles.FONTFAMILY[offset]) {\n    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n  }\n  if (inlineStyles.SUBSCRIPT[offset]) {\n    styles.SUBSCRIPT = true;\n  }\n  if (inlineStyles.SUPERSCRIPT[offset]) {\n    styles.SUPERSCRIPT = true;\n  }\n  if (inlineStyles.CODE[offset]) {\n    styles.CODE = true;\n  }\n  if (inlineStyles.STRIKETHROUGH[offset]) {\n    styles.STRIKETHROUGH = true;\n  }\n  if (inlineStyles.UNDERLINE[offset]) {\n    styles.UNDERLINE = true;\n  }\n  if (inlineStyles.ITALIC[offset]) {\n    styles.ITALIC = true;\n  }\n  if (inlineStyles.BOLD[offset]) {\n    styles.BOLD = true;\n  }\n  return styles;\n}\n\n/**\n* For a given section in a block the function will return a further list of sections,\n* with similar inline styles applicable to them.\n*/\nfunction getStyleSections(\n  block: Object,\n  styles: Array<string>,\n  start: number,\n  end: number,\n): Array<Object> {\n  const styleSections = [];\n  const { text } = block;\n  if (text.length > 0) {\n    const inlineStyles = getStyleArrayForBlock(block);\n    let section;\n    for (let i = start; i < end; i += 1) {\n      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n        // $FlowFixMe\n        section.text.push(text[i]);\n        // $FlowFixMe\n        section.end = i + 1;\n      } else {\n        section = {\n          styles: getStylesAtOffset(inlineStyles, i),\n          text: [text[i]],\n          start: i,\n          end: i + 1,\n        };\n        styleSections.push(section);\n      }\n    }\n  }\n  return styleSections;\n}\n\n/**\n* The function returns text for given section of block after doing required character replacements.\n*/\nfunction getSectionText(text: Array<string>): string {\n  if (text && text.length > 0) {\n    const chars = text.map((ch) => {\n      switch (ch) {\n        case '\\n':\n          return '\\\\s\\\\s\\n';\n        case '&':\n          return '&amp;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        default:\n          return ch;\n      }\n    });\n    return chars.join('');\n  }\n  return '';\n}\n\n/**\n* Function returns markdown for inline style symbols.\n*/\nexport function addInlineStyleMarkup(style: string, content: string): string {\n  if (style === 'BOLD') {\n    return `**${content}**`;\n  } else if (style === 'ITALIC') {\n    return `*${content}*`;\n  } else if (style === 'UNDERLINE') {\n    return `__${content}__`;\n  } else if (style === 'STRIKETHROUGH') {\n    return `~~${content}~~`;\n  } else if (style === 'CODE') {\n    return `\\`${content}\\``;\n  } else if (style === 'SUPERSCRIPT') {\n    return `<sup>${content}</sup>`;\n  } else if (style === 'SUBSCRIPT') {\n    return `<sub>${content}</sub>`;\n  }\n  return content;\n}\n\n/**\n* The method returns markup for section to which inline styles\n* BOLD, UNDERLINE, ITALIC, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n*/\nfunction getStyleTagSectionMarkdown(styles: Object, text: string): string {\n  let content = text;\n  forEach(styles, (style, value) => {\n    content = addInlineStyleMarkup(style, content, value);\n  });\n  return content;\n}\n\n/**\n* Function returns html for text applying inline style in styles property in a span.\n*/\nexport function addStylePropertyMarkdown(styleSection: Object): string {\n  const { styles, text } = styleSection;\n  const content = getSectionText(text);\n  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n    let styleString = 'style=\"';\n    if (styles.COLOR) {\n      styleString += `color: ${styles.COLOR};`;\n    }\n    if (styles.BGCOLOR) {\n      styleString += `background-color: ${styles.BGCOLOR};`;\n    }\n    if (styles.FONTSIZE) {\n      styleString += `font-size: ${styles.FONTSIZE}px;`;\n    }\n    if (styles.FONTFAMILY) {\n      styleString += `font-family: ${styles.FONTFAMILY};`;\n    }\n    styleString += '\"';\n    return `<span ${styleString}>${content}</span>`;\n  }\n  return content;\n}\n\n/**\n* The method returns markdown for an entity section.\n* An entity section is a continuous section in a block\n* to which same entity or no entity is applicable.\n*/\nfunction getEntitySectionMarkdown(block: Object, entityMap: Object, entitySection: Object): string {\n  const entitySectionMarkdown = [];\n  const styleSections = getStyleSections(\n    block,\n    ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'],\n    entitySection.start,\n    entitySection.end,\n  );\n  let styleSectionText = '';\n  styleSections.forEach((styleSection) => {\n    const stylePropertySections = getStyleSections(\n      block,\n      ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'],\n      styleSection.start,\n      styleSection.end,\n    );\n    let stylePropertySectionText = '';\n    stylePropertySections.forEach((stylePropertySection) => {\n      stylePropertySectionText += addStylePropertyMarkdown(stylePropertySection);\n    });\n    styleSectionText += getStyleTagSectionMarkdown(styleSection.styles, stylePropertySectionText);\n  });\n  entitySectionMarkdown.push(styleSectionText);\n  let sectionText = entitySectionMarkdown.join('');\n  if (entitySection.entityKey !== undefined && entitySection.entityKey !== null) {\n    sectionText = getEntityMarkdown(entityMap, entitySection.entityKey, sectionText);\n  }\n  return sectionText;\n}\n\n/**\n* Replace leading blank spaces by &nbsp;\n*/\nexport function trimLeadingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = 0; i < replacedText.length; i += 1) {\n      if (sectionText[i] === ' ') {\n        replacedText = replacedText.replace(' ', '&nbsp;');\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Replace trailing blank spaces by &nbsp;\n*/\nexport function trimTrailingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = replacedText.length - 1; i >= 0; i -= 1) {\n      if (replacedText[i] === ' ') {\n        replacedText = `${replacedText.substring(0, i)}&nbsp;${replacedText.substring(i + 1)}`;\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Function will return the markdown for block content.\n*/\nexport function getBlockContentMarkdown(block: Object, entityMap: Object): string {\n  if (isAtomicBlock(block)) {\n    return getEntityMarkdown(entityMap, block.entityRanges[0].key, '');\n  }\n  const blockMarkdown = [];\n  const entitySections = getEntitySections(block.entityRanges, block.text.length);\n  entitySections.forEach((section, index) => {\n    let sectionText = getEntitySectionMarkdown(block, entityMap, section);\n    if (index === 0) {\n      sectionText = trimLeadingZeros(sectionText);\n    }\n    if (index === entitySections.length - 1) {\n      sectionText = trimTrailingZeros(sectionText);\n    }\n    blockMarkdown.push(sectionText);\n  });\n  return blockMarkdown.join('');\n}\n\n/**\n* Function will return style string for a block.\n*/\nexport function getBlockStyle(data: Object): string {\n  let styles = '';\n  forEach(data, (key, value) => {\n    styles += `${key}:${value};`;\n  });\n  return styles;\n}\n\n/**\n* FUnciton will add <span> with style property aroung block content for block level text-styling.\n*/\nfunction getBlockStyleProperty(blockData: Object, content: string) {\n  const blockStyle = getBlockStyle(blockData);\n  if (blockStyle) {\n    return `<span style=\"${blockStyle}\">${content}</span>`;\n  }\n  return content;\n}\n\n/**\n* Function will return markdown for the block.\n*/\nfunction getBlockMarkdown(block: Object, entityMap: Object): string {\n  const blockMarkdown = [];\n  blockMarkdown.push(getBlockTagSymbol(block));\n  let blockContentMarkdown = getBlockContentMarkdown(block, entityMap);\n  if (block.data) {\n    blockContentMarkdown = getBlockStyleProperty(block.data, blockContentMarkdown);\n  }\n  blockMarkdown.push(blockContentMarkdown);\n  blockMarkdown.push('\\n');\n  return blockMarkdown.join('');\n}\n\nfunction getDepthPadding(depth: number) {\n  let padding = '';\n  for (let i = 0; i < depth * 4; i += 1) {\n    padding += ' ';\n  }\n  return padding;\n}\n\n/**\n* The function will generate markdown for given draftjs editorContent.\n*/\nexport default function draftToMarkdown(editorContent: Object): string {\n  const markdown = [];\n  if (editorContent) {\n    const { blocks, entityMap } = editorContent;\n    if (blocks && blocks.length > 0) {\n      blocks.forEach((block) => {\n        let content = getBlockMarkdown(block, entityMap);\n        if (isList(block.type)) {\n          content = getDepthPadding(block.depth) + content;\n        }\n        markdown.push(content);\n      });\n    }\n  }\n  return markdown.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/index.js"],"sourceRoot":""}